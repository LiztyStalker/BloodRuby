//------------------------------------------------------------------------------
// <auto-generated>
//     이 코드는 도구를 사용하여 생성되었습니다.
//     런타임 버전:4.0.30319.36373
//
//     파일 내용을 변경하면 잘못된 동작이 발생할 수 있으며, 코드를 다시 생성하면
//     이러한 변경 내용이 손실됩니다.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;


public enum TYPE_CONSTRAINT{
	INVISIBLE, 
	PENETRATE, 
	TELESCOPE_ATTACK, 
	WEAPON_CHANGE, 
	NOT_ATTACK, 
	NOT_MOVE,
	NOT_ROTATE,
	NOT_SKILL
}

public class AddStateClass : MonoBehaviour
{
    [SerializeField] ValueAddStateClass m_valueState;
	ICharacterInterface m_character;

	ValueAddStateClass[] m_valueArray;

	//버프 리스트
	List<BuffDataClass> m_buffList = new List<BuffDataClass>();


//	Dictionary<Type, BuffDataClass> m_buffDic = new Dictionary<Type, BuffDataClass> ();

//	private int m_buffList{ get { return m_buffDic.Values; } }


//	int m_shield = 0; //실드

	Dictionary<TYPE_CONSTRAINT, List<BuffDataClass>> m_constraintDic = new Dictionary<TYPE_CONSTRAINT, List<BuffDataClass>>();

//	Dictionary<string, TYPE_CONSTRAINT> m_constraintDic = new Dictionary<string, TYPE_CONSTRAINT> ();

//	bool m_isInvisible = false; //무적 판정
//	bool m_isPenetrate = false; //관통 판정
//	bool m_isTelescopeAttack = false; //망원경 공격가능
//	bool m_isWeaponChange = false; //무기 바꾸기
//	bool m_isNotAttack = false; //공격불가
//	bool m_isNotMove = false; //이동불가


	/// <summary>
	/// 현재 실드
	/// </summary>
	public int nowShield{ get{ return m_buffList.Where (buffData => buffData.GetType () == typeof(ShieldBuffDataClass)).Sum (buffData => buffData.count);} } //실드

	/// <summary>
	/// 최대 실드
	/// </summary>
	public int maxShield{ get{ return m_buffList.Where (buffData => buffData.GetType () == typeof(ShieldBuffDataClass)).Sum (buffData => ((ShieldBuffDataClass)buffData).shieldMax);} } //실드

	public ICharacterInterface character{ get { return m_character; } }

//	public bool isInvisible { get { return m_isInvisible; } set { m_isInvisible = value; }  } //무적 판정
//	public bool isPenetrate { get { return  m_isPenetrate; } set { m_isPenetrate = value; }  } //관통
//	public bool isTelescopeAttack { get { return  m_isTelescopeAttack; } set{ m_isTelescopeAttack = value; }} //망원경 공격가능
//	public bool isWeaponChange{ get { return  m_isWeaponChange; } } //무기 바꾸기
//	public bool isNotAttack { get { return m_isNotAttack; } set { m_isNotAttack = value; } } //공격불가
//	public bool isNotMove {get{return m_isNotMove;} set{m_isNotMove = value;}} //이동불가

	
	private bool isZero(int value1, int value2){ return (value1 - value2 < 0) ? true : false;}
	private bool isZero(float value1, float value2){ return (value1 - value2 < 0) ? true : false;}


//	public void setShield(int shield){
//		m_shield = shield;
//		//실드 생성 파티클
//		//
//	}

	/// <summary>
	/// 실드 피격 true 실드 있음
	/// </summary>
	/// <returns><c>true</c>, if shield was hit, <c>false</c> otherwise.</returns>
	/// <param name="damage">Damage.</param>
//	public bool hitShield(int damage){
//		if (maxShield > 0) {
//			if (nowShield - damage <= 0) {
//				nowShield = 0;
//				return false;
//			}
//		}
//		m_shield -= damage;
//		return true;
//	}

	public void initAddState(ICharacterInterface character){
		m_character = character;
		//m_valueArray = (ValueAddStateClass[])GetComponents<ValueAddStateClass> ().Clone();
        ValueAddStateClass[] m_valueTmp =  m_valueState.GetComponents<ValueAddStateClass>();
        m_valueArray = new ValueAddStateClass[m_valueTmp.Length];
        //Debug.Log("length : " + m_valueArray.Length);

        for (int i = 0; i < m_valueArray.Length; i++)
        {
            m_valueArray[i] = (ValueAddStateClass)gameObject.AddComponent(m_valueTmp[i].GetType());
        }

		foreach(TYPE_CONSTRAINT constraint in Enum.GetValues(typeof(TYPE_CONSTRAINT))){
			m_constraintDic.Add(constraint, new List<BuffDataClass>());
		}



	}

	/// <summary>
	/// 버프 삽입
	/// </summary>
	/// <returns>삽입된 버프 - null : 버프 종료.</returns>
	/// <param name="buffData">삽입할 버프.</param>
	/// <param name="act_character">버프 시전자.</param>
	/// <param name="act_character">버프 걸리는 캐릭터.</param>
	public BuffDataClass buffAdd(BuffDataClass buffData, ICharacterInterface ownerCharacter, ICharacterInterface actCharacter){
		//능력 활성화
		//버프가 토글형식이면 
		if (m_buffList.Count > 0) {

            List<BuffDataClass> tmpBuffList = m_buffList.ToList ();
			
            foreach (BuffDataClass tmpBuff in tmpBuffList) {

				//같은 그룹이면 조건에 맞게 갱신
				if (tmpBuff.group == buffData.group) {
					switch (tmpBuff.buffState) {
					case TYPE_BUFF_STATE.TIME:
						goto case TYPE_BUFF_STATE.COUNT;
					case TYPE_BUFF_STATE.COUNT:
						//버프 갱신
                            
						//희생버프가 걸려있을때 사용 - 현재 희생버프 삭제 후 실행
						//희생버프가 걸려있을 때 다른 희생버프 받음 - 무시
						//희생 버프는 주인이 같아야 함
						//주인이 다르면 - 무시
						if (tmpBuff.GetType () == typeof(InstanceTaggingBuffDataClass)) {
							if (buffData.GetType () == typeof(SacrificeTagBuffStateClass)) {
								//무시
								return null;
							}
						} else if (tmpBuff.GetType () == typeof(SacrificeTagBuffStateClass)) {

							if (buffData.GetType () == typeof(InstanceTaggingBuffDataClass)) {
								//m_buffList.Remove (tmpBuff);
								tmpBuff.buffEnd ();
								break;
							} else if (buffData.GetType () == typeof(SacrificeTagBuffStateClass)) {
								//무시
								return null;
							}

						}
						tmpBuff.buffReplace ();
						return null;
					case TYPE_BUFF_STATE.TOGGLE:
						//버프 종료
						Debug.Log("버프종료");
						tmpBuff.buffEnd();
						return null;
					}
				}
			}
		}

		//버프 삽입
		BuffDataClass buffObj = (BuffDataClass)MonoBehaviour.Instantiate (buffData, character.transform.position, Quaternion.identity);
		buffObj.transform.SetParent (character.transform);
		buffObj.transform.eulerAngles = new Vector3 (0f, 0f, character.angle);
		buffObj.buffStart (ownerCharacter, actCharacter);
		buffObj.icon = buffData.icon;
		m_buffList.Add (buffObj);
		return buffObj;
	}


	/// <summary>
	/// 제약조건 셋
	/// </summary>
	/// <returns><c>true</c>, if constraint was set, <c>false</c> otherwise.</returns>
	/// <param name="buffData">Buff data.</param>
	/// <param name="constraint">Constraint.</param>
	public bool setConstraint(BuffDataClass buffData, TYPE_CONSTRAINT[] constraintList){

		if (constraintList != null) {
//			Debug.Log ("constraintCount : " + constraintList.Length);
			foreach (TYPE_CONSTRAINT typeConstraint in constraintList) {
//				m_constraintDic.Add (string.Format("{0}{1}", buffData.GetInstanceID(), (int)typeConstraint), typeConstraint);


				if (m_constraintDic.ContainsKey (typeConstraint)) {
					m_constraintDic [typeConstraint].Add (buffData);
				}

			}
			return true;
		}
		return false;
	}

	/// <summary>
	/// 제약조건 리셋
	/// </summary>
	/// <returns><c>true</c>, if constraint was reset, <c>false</c> otherwise.</returns>
	/// <param name="buffData">Buff data.</param>
	public bool resetConstraint(BuffDataClass buffData, TYPE_CONSTRAINT[] constraintList){

		if (constraintList != null) {
			foreach (TYPE_CONSTRAINT typeConstraint in constraintList) {


//				m_constraintDic.Remove (string.Format("{0}{1}", buffData.GetInstanceID(), (int)typeConstraint))

				if (m_constraintDic.ContainsKey (typeConstraint)) {


					m_constraintDic [typeConstraint].Remove (buffData);
//					Debug.LogWarning ("reset : " + buffData + " " + character.playerName);

				}


			}
		}
		return true;
	}

	/// <summary>
	/// 제약조건 체크
	/// </summary>
	/// <returns><c>true</c>, if constraint was ised, <c>false</c> otherwise.</returns>
	/// <param name="constraint">Constraint.</param>
	public bool isConstraint(TYPE_CONSTRAINT constraint){
		if (m_constraintDic.ContainsKey (constraint)) {
			//각 제약조건에 하나 이상의 버프가 있으면 true
			if (m_constraintDic [constraint].Count > 0)
				return true;
		}
		return false;
	}


	/// <summary>
	/// 버프 사용하기
	/// </summary>
	/// <returns><c>true</c>, if buff was used, <c>false</c> otherwise.</returns>
	/// <param name="character">버프에 당하는 캐릭터</param>
	/// <param name="bullet">탄환</param>
	/// <param name="buffState">버프 상태</param>
	public bool useBuff(ICharacterInterface character, IBullet bullet, TYPE_BUFF_STATE_ACT buffStateAct){
		//현재 버프 스테이트에 맞는 모든 버프 실행


		if (m_buffList.Count > 0) {
//			Debug.Log ("버프있음");

			List<BuffDataClass> useBuffList = m_buffList.Where(buffData => buffData.buffStateAct.Get((int)buffStateAct)).ToList<BuffDataClass>();

			foreach(BuffDataClass useBuff in useBuffList){
				if (useBuff.useBuff (character, bullet))
					return true;
			}
		}
		return false;
	}

	/// <summary>
	/// 버프 사용하기
	/// </summary>
	/// <returns><c>true</c>, if buff was used, <c>false</c> otherwise.</returns>
	/// <param name="character">버프에 당하는 캐릭터</param>
	/// <param name="buffState">버프 상태</param>
	public bool useBuff(ICharacterInterface character, TYPE_BUFF_STATE_ACT buffStateAct){
		if (m_buffList.Count > 0) {
			List<BuffDataClass> useBuffList = m_buffList.Where(buffData => buffData.buffStateAct.Get((int)buffStateAct)).ToList<BuffDataClass>();
//			Debug.Log ("버프있음 : " + buffState);

			foreach(BuffDataClass useBuff in useBuffList){

//				Debug.Log ("버프리스트 : " + useBuff.buffState.Get((int)buffState));
				if (useBuff.useBuff (character))
					return true;
			}
		}
		return false;
	}


	/// <summary>
	/// 버프 강제 종료
	/// </summary>
//	public void buffPowerOff(BuffDataClass buffData){
//		buffData.buffEnd ();
//	}

	/// <summary>
	/// 버프 종료하기
	/// </summary>
	/// <returns>파괴된 버프 가오기. : null 파괴된 버프 없음</returns>
	/// <param name="buffData">현재 버프</param>
	public bool buffEnd(BuffDataClass buffData){


//		if (buffData.count <= 0) {
//		buffData.buffEnd ();
		if (!m_buffList.Remove (buffData)){
//				Debug.LogWarning ("삭제 불가 : " + buffData.GetType());
				return false;
			}

//		foreach (BuffDataClass buff in m_buffList) 
//			Debug.LogWarning ("Bufflist : " + buff.GetType () + " " + buff.actCharacter.playerName);
		


//		Debug.LogWarning ("삭제 : " + buffData.GetType ());
		m_character.buffEndPanel (buffData);
		Destroy (buffData.gameObject);
		return true;
//		} else {
////	체력 회복이면 1개 까여야 함
//			return buffData.buffEnd ();
//		}

//		foreach (BuffDataClass bf in m_buffList) {
//			Debug.Log ("현재버프 : " + bf.name);
//		}

	}

	/// <summary>
	/// 타입형으로 버프 찾기
	/// </summary>
	/// <returns>파괴된 버프 가오기. : null 버프 못찾음</returns>
	/// <param name="buffClass">버프클래스.</param>
	public bool buffEnd(Type buffClass){
		BuffDataClass buffData = m_buffList.Where (buff => buff.GetType () == buffClass).SingleOrDefault ();

		if (buffData != null) {
//			Debug.Log ("버프 지우기 : " + buffData.GetType ());

			return buffEnd (buffData);
		}
		return false;
	}

	/// <summary>
	/// 버프 가져오기
	/// </summary>
	/// <returns>The buff.</returns>
	/// <param name="buffClass">Buff class.</param>
	public BuffDataClass getBuff(Type buffClass){
//		if(buffClass.BaseType == typeof(BuffDataClass))
			return m_buffList.Where (buff => buff.GetType () == buffClass).SingleOrDefault<BuffDataClass> ();
//		Debug.LogWarning ("notBuff : " + buffClass);
//		return null;
	}
	
	/// <summary>
	/// 값 넣기
	/// </summary>
	/// <returns><c>true</c>, if value was set, <c>false</c> otherwise.</returns>
	/// <param name="value">Value.</param>
	/// <param name="data">Data.</param>
	public bool setValue(ValueAddStateClass data, BuffDataClass buffData)
	{
		
		ValueAddStateClass dataClass = getValue(data.GetType());
		
		if (dataClass != null) {
//			Debug.Log ("setValue : " + data.value + " " + data.GetType());
			dataClass.addValue(data, buffData);
			return true;
		}
		
		return false;
		
	}
	
	/// <summary>
	/// 값 빼기
	/// </summary>
	/// <returns><c>true</c>, if value was set, <c>false</c> otherwise.</returns>
	/// <param name="value">Value.</param>
	/// <param name="data">Data.</param>
	public bool returnValue(ValueAddStateClass data, BuffDataClass buffData)
	{
		
		ValueAddStateClass dataClass = getValue(data.GetType());
		
		if (dataClass != null) {
			//Debug.Log ("returnValue : " + dataClass.GetInstanceID ());
			dataClass.returnValue(data, buffData);
			return true;
		}
		return false;
	}
	
	/// <summary>
	/// 값 가져오기
	/// </summary>
	/// <returns>The calculator.</returns>
	/// <param name="value">Value.</param>
	/// <param name="data">Data.</param>
	public float valueCalculator(float value, Type valueType){
		ValueAddStateClass dataClass = getValue(valueType);
		
		if (dataClass != null) {
			return dataClass.valueCalculator(value);
		}
		return 1f;
		
	}

	/// <summary>
	/// 값 가져오기
	/// </summary>
	/// <returns>The calculator.</returns>
	/// <param name="value">Value.</param>
	/// <param name="data">Data.</param>
	public float valueCalculator(float value, Type valueType, Type[] excBuffType){
		ValueAddStateClass dataClass = getValue(valueType);

		if (dataClass != null) {
			return dataClass.valueCalculator(value, excBuffType);
		}
		return 1f;

	}

	
	private ValueAddStateClass getValue(Type type){
		return (ValueAddStateClass)m_valueArray.Where (valueDat => valueDat.GetType () == type).SingleOrDefault ();
	}

	/// <summary>
	/// 캐릭터 지워질 때 현재 걸려있는 모든 버프 종료
	/// </summary>
	public void buffEndAll(){
		List<BuffDataClass> m_tmpList = m_buffList.ToList<BuffDataClass>();
		foreach (BuffDataClass buff in m_tmpList) {
			buff.buffEnd ();
		}

	}


}



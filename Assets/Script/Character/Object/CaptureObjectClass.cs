//------------------------------------------------------------------------------
// <auto-generated>
//     이 코드는 도구를 사용하여 생성되었습니다.
//     런타임 버전:4.0.30319.36373
//
//     파일 내용을 변경하면 잘못된 동작이 발생할 수 있으며, 코드를 다시 생성하면
//     이러한 변경 내용이 손실됩니다.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using UnityEngine;
using System.Linq;

public class CaptureObjectClass : ActionObjectClass
{

	//전체적으로 리팩토링 필요

	//거점 색상 - 팀0, 팀1, 팀2, 팀3, 중립
	//const float c_timeGap = 0.1f; //루프 1회 시간 0.1초
	const int c_captureMax = 100; //거점점령 최대값
	const int c_captureValue = 1; //거점점령 0.1초당 상승값
	const int c_captureUnitMax = 3; //최대 거점 점령 인원 수
	const float c_captureArea = 1.5f;// 점령 범위

	//public delegate void flagDelegate(TYPE_TEAM nowteam, TYPE_TEAM capteam, float rate);

	//flagDelegate m_flagDel;// = new flagDelegate();
	

	string m_flagTag = "-"; //거점 번호
	[SerializeField] string m_name; //거점 이름
    [SerializeField] bool m_isCaptured = true; //거점 점령 가능 여부 - true 가능

	[SerializeField] Vector2 m_rect = Vector2.zero; //리스폰 영역
//	[SerializeField] SpriteRenderer m_RespawnRect;
//	[SerializeField] int m_point; 
	[SerializeField] GameObject m_captureEffect;

	int[] m_flagList, m_capturedTeam; //거점 점수, 거점 점령 지수

	TYPE_MODE m_mode; //전투 모드
	TYPE_TEAM firstTeam, secondTeam = TYPE_TEAM.NONE;
	int totalMax, firstMax, secondMax = 0;

	Vector2 m_respawnPos = Vector2.zero;

    public delegate void CaptureBroadCastDelegate(string msg, TYPE_TEAM team);

    CaptureBroadCastDelegate m_captureBroadCast;



	public TYPE_MODE mode{get{ return m_mode; }}

    public string flagTag { get { return m_flagTag; } set { m_flagTag = value; } }

	/// <summary>
	/// 거점 점령 여부 - true 가능
	/// </summary>
	/// <value><c>true</c> if is captured; otherwise, <c>false</c>.</value>
	public bool isCaptured{get{return m_isCaptured;} set{m_isCaptured = value;}}

	/// <summary>
	/// 점령중인 팀 가져오기
	/// 고착 상태 - 선 점령 팀 가져오기
	/// 점령자 - 점령팀
	/// 아무도 없음 - 중립
	/// </summary>
	/// <value>The capteam.</value>
	public TYPE_TEAM capteam {
		get{
			//Debug.Log("totalMax : " + totalMax);
			//중립상태 거점일 때
			//고착상태이면 선 점령한 팀만 보여줌
			if(team == TYPE_TEAM.NONE){
				if(firstMax > 0 && secondMax > 0){
					for(int i = 0; i < m_flagList.Length; i++)
						if(m_flagList[i] > 0) return (TYPE_TEAM)i;
				}
			}

			//점령자
			if(totalMax > 0)
				return firstTeam;
			//점령자
			else if( totalMax < 0)
				return secondTeam;
			//점령자 없음
			else 
				return TYPE_TEAM.NONE;
		}
	}

	/// <summary>
	/// 점령 스코어
	/// 팀 - 팀 스코어
	/// 적 또는 중립 - 0
	/// </summary>
	/// <returns>The score.</returns>
	/// <param name="team">Team.</param>
	public int flagScore(TYPE_TEAM team){
		switch (team) {
		case TYPE_TEAM.ENEMY:
			return 0;
		case TYPE_TEAM.NONE:
			goto case TYPE_TEAM.ENEMY;
		default :
			return m_flagList[(int)team]; 
		}
	}

	/// <summary>
	/// 리스폰 위치 가져오기
	/// </summary>
	/// <value>The respawn position.</value>
	public Vector2 respawnPos {
		get{
			//리스폰 조건
			//리스폰 가능한 위치 조정
			//해당 위치에서 반경 0.4 이내에 사물이 있으면 재탐색
			//사물이 없으면 리스폰 위치 가져오기

			//리스폰 위치 = 리스폰위치X + 랜덤(가로너비), 리스폰위치Y + 랜덤(세로너비)
			float posX = transform.position.x + UnityEngine.Random.Range(m_rect.x * -0.5f, m_rect.x * 0.5f);
			float posY = transform.position.y + UnityEngine.Random.Range(m_rect.y * -0.5f, m_rect.y * 0.5f);
			m_respawnPos.Set(posX, posY);
			return m_respawnPos;
		}
	}


	public void setMode(TYPE_MODE mode){
		m_mode = mode;
		switch (mode) {
		case TYPE_MODE.TOTALWAR:
			break;
		case TYPE_MODE.CAPTURE:
			break;
		case TYPE_MODE.SIEGE:
			break;
		case TYPE_MODE.BASE_ATTACK:
			break;
		case TYPE_MODE.BASE_DEFENCE:
			break;
		}
	}

    public void setBroadCast(CaptureBroadCastDelegate del)
    {
		m_captureBroadCast = del;
//		Debug.Log ("setBroad");
    }

	void Awake(){
		//m_flagDel = new flagDelegate ();
		m_captureEffect.SetActive (false);
		m_flagList = new int[Enum.GetValues(typeof(TYPE_TEAM)).Length - 2];
		m_capturedTeam = new int[Enum.GetValues (typeof(TYPE_TEAM)).Length - 2];

		if (m_team != TYPE_TEAM.NONE) {
			m_flagList [(int)m_team] = c_captureMax;
		}

		GetComponent<SpriteRenderer> ().color = PrepClass.getFlagColor (m_team);
	}



//	public void addFlagDelegate(flagDelegate flagDel){
//		m_flagDel = flagDel;
//	}
//
//	public void removeFlagDelegate(flagDelegate flagDel){
//		m_flagDel = flagDel;
//	}

	void Start(){

//		gameObject.AddComponent<Rigidbody2D> ().gravityScale = 0f;
//		GetComponent<Rigidbody2D> ().isKinematic = true;
//
//		gameObject.AddComponent<CircleCollider2D> ().isTrigger = true;
//		GetComponent<CircleCollider2D> ().radius = 0.5f;
		if(isCaptured) StartCoroutine (captureLoop());
	}


	void OnDrawGizmos(){
		Gizmos.color = Color.blue;
		Gizmos.DrawWireCube (transform.position, m_rect);
		Gizmos.DrawWireSphere  (transform.position, c_captureArea);
	}



//	void OnTriggerEnter2D(Collider2D col){
//		//캐릭터 팀이면 해당 팀 카운터 1 증가
//
//		if(!isCaptured) return;
//
//
//		if (PrepClass.isCharacterTag(col.tag))
//		{
//
//			//if (!col.GetComponent<ICharacterInterface> ().isDead) {
//
//				//현재 점령중에 있는 팀 가져오기
//				TYPE_TEAM teamHit = col.GetComponent<ICharacterInterface> ().team;
//				//중립이거나 적이 아니면 팀 점령인원 삽입
//
//				if (team != teamHit)
//					col.GetComponent<ICharacterInterface> ().setMsg (flagTag + " 거점 점령중", this);
//				else
//					col.GetComponent<ICharacterInterface> ().setMsg ("", this);
//
//				if (teamHit != TYPE_TEAM.NONE && teamHit != TYPE_TEAM.ENEMY) 
//					m_capturedTeam [(int)teamHit]++;
//			Debug.Log ("capIn " + name + " " + m_capturedTeam [0] + m_capturedTeam [1] + m_capturedTeam [2] + m_capturedTeam [3]);
//				
//			}
//		//}
//	}
//
//	void OnTriggerExit2D(Collider2D col){
//		//캐릭터 팀이면 해당 팀 카운터 1 감소
//		if(!isCaptured)return;
//
//
//		if (PrepClass.isCharacterTag(col.tag))
//		{
//
//			//if (!col.GetComponent<ICharacterInterface> ().isDead) {
//
//				//현재 점령에서 나간 팀 가져오기
//				TYPE_TEAM teamHit = col.GetComponent<ICharacterInterface> ().team;
//				//중립이거나 적이 아니면 팀 점령인원 삽입
//				col.GetComponent<ICharacterInterface> ().closeMsg();
//
//				if (teamHit != TYPE_TEAM.NONE && teamHit != TYPE_TEAM.ENEMY) {
//					if (m_capturedTeam [(int)teamHit] > 0)
//						m_capturedTeam [(int)teamHit]--;
//
//
//				}
//
//			Debug.Log ("capOut : " + name + " " + m_capturedTeam [0] + m_capturedTeam [1] + m_capturedTeam [2] + m_capturedTeam [3]);
//			//}
//		}
//	}


	void setFlagCalculator(TYPE_TEAM capTeam, int cnt){
		Debug.Log ("setFlag : " + capTeam + " " + cnt);
		m_flagList[(int)capTeam] += cnt;
		flagColor(capTeam);
	}

	IEnumerator captureLoop(){

		while (gameObject.activeSelf) {
			
			//거점 점령 불가인 경우 무시 - 게임이 끝나면 일괄적으로 거점 점령 불가
			if(!isCaptured)break;


			for (int i = 0; i < m_capturedTeam.Length; i++) 
				m_capturedTeam [i] = 0;
			

			RaycastHit2D[] hits = Physics2D.CircleCastAll (transform.position, c_captureArea, Vector2.zero);

			foreach(RaycastHit2D hit in hits){

				if (PrepClass.isCharacterTag(hit.collider.tag))
				{
		
					if (!hit.collider.GetComponent<ICharacterInterface> ().isDead) {
		
						//현재 점령중에 있는 팀 가져오기
						TYPE_TEAM teamHit = hit.collider.GetComponent<ICharacterInterface> ().team;
						//중립이거나 적이 아니면 팀 점령인원 삽입
		
//						if (team != teamHit)
//							hit.collider.GetComponent<ICharacterInterface> ().setFlagCapture (this);
//						else
						hit.collider.GetComponent<ICharacterInterface> ().setMsg (flagTag, this);
		
						if (teamHit != TYPE_TEAM.NONE && teamHit != TYPE_TEAM.ENEMY)
							m_capturedTeam [(int)teamHit]++;
//						Debug.Log ("capIn " + name + " " + m_capturedTeam [0] + m_capturedTeam [1] + m_capturedTeam [2] + m_capturedTeam [3]);
					}
						
				}
				//}
			}


			//점령중
			if (m_capturedTeam.Sum () > 0) {


				//점령팀수 루프 - 높은 점령팀, 낮은 점령팀
				firstTeam = secondTeam = TYPE_TEAM.NONE;
				firstMax = secondMax = 0;

				//높은 점령팀 가져오기
				for (int i = 0; i < m_capturedTeam.Length; i++) {
					if (m_capturedTeam [i] > firstMax) {
						firstTeam = (TYPE_TEAM)i;
						if (m_capturedTeam [i] > c_captureUnitMax)
							firstMax = c_captureUnitMax;
						else
							firstMax = m_capturedTeam [i];
					}
				}

				//낮은 점령팀 가져오기
				for (int i = 0; i < m_capturedTeam.Length; i++) {

					//높은 점령팀이 있으면 무시
					if (firstTeam == (TYPE_TEAM)i)
						continue;

					//다른 팀이면 비교하여 두번째로 거점량이 많은 팀 가져오기
					if (m_capturedTeam [i] > secondMax) {
						secondTeam = (TYPE_TEAM)i;
						if (m_capturedTeam [i] > c_captureUnitMax)
							secondMax = c_captureUnitMax;
						else
							secondMax = m_capturedTeam [i];
					}
				}

				//총팀 = 높은팀 - 낮은팀
				totalMax = firstMax;// - secondMax;

				//높은팀 기준



				//모드선택
				//거점 공방전, 전면전, 등등
				switch (m_mode) {
				case TYPE_MODE.TOTALWAR:
					//총팀 = 높은팀 : 적 거점을 아무도 점령하지 않음
					//if (totalMax != 0 && totalMax == firstMax && secondMax == 0) {
					if (totalMax != 0 && secondMax == 0) {
						//깃발이 중립이면
						if (team == TYPE_TEAM.NONE) {
							
							setFlagCalculator (firstTeam, totalMax);

							if (m_flagList [(int)firstTeam] >= 100) {
								m_flagList [(int)firstTeam] = 100;


								//거점 점령 카운트 업
								foreach (RaycastHit2D hit in hits) {
									if (PrepClass.isCharacterTag (hit.collider.tag)) {
										if(hit.collider.GetComponent<ICharacterInterface> ().team == firstTeam){
											if (!hit.collider.GetComponent<ICharacterInterface> ().isDead) {
												hit.collider.GetComponent<ICharacterInterface> ().addReport (1, hit.collider.GetComponent<ICharacterInterface> ().mos, TYPE_REPORT.FLAG_CAP);
											}
										}
									}
								}

								flagChange (firstTeam);
							}
						} 
						//깃발이 적군것
						else if (team != firstTeam) {
							//점수 하락
							setFlagCalculator (team, -totalMax);
							if (m_flagList [(int)team] <= 0) {
								m_flagList [(int)team] = 0;
								//거점 중립 카운트 업

								//거점 중립 카운트 업
								foreach (RaycastHit2D hit in hits) {
									if (PrepClass.isCharacterTag (hit.collider.tag)) {
										if(hit.collider.GetComponent<ICharacterInterface> ().team == firstTeam){
											if (!hit.collider.GetComponent<ICharacterInterface> ().isDead) {
												hit.collider.GetComponent<ICharacterInterface> ().addReport (1, hit.collider.GetComponent<ICharacterInterface> ().mos, TYPE_REPORT.FLAG_NAT);
											}
										}
									}
								}


								flagChange (TYPE_TEAM.NONE);

							}
						}

						//같은팀 깃발
						else {
							//회복
							if (m_flagList [(int)firstTeam] < 100)
								setFlagCalculator (firstTeam, 1);
						}
					}
					//적군도 한명 이상 점령하면
					//교착상태
					//else {}
					break;
				case TYPE_MODE.CAPTURE:
					goto case TYPE_MODE.TOTALWAR;
				case TYPE_MODE.SIEGE:
					goto case TYPE_MODE.TOTALWAR;

				case TYPE_MODE.BASE_ATTACK:
					//공격 - 거점 점령시 바로 아군팀으로 전환
					//점령된 거점은 재점령 불가
					//점령속도 느림
					goto case TYPE_MODE.TOTALWAR;
				case TYPE_MODE.BASE_DEFENCE:
					goto case TYPE_MODE.BASE_ATTACK;
				}
			}

			//거점을 점령한 캐릭터가 아무도 없으면
			else{

				//중립이면
				if(team == TYPE_TEAM.NONE){
					for (int i = 0; i < m_flagList.Length; i++) {
						if (m_flagList [i] > 0) {
							//조금씩 감산
							m_flagList [i] -= c_captureValue;
							flagColor ((TYPE_TEAM)i);
							//색 점차 변환
						}
					}
				} 
				else {
					if(m_flagList[(int)team] < 100) setFlagCalculator (team, 1);
				}
			}

			

			

//			Debug.Log ("cap : " + m_flagList [0] + m_flagList [1] + m_flagList [2] + m_flagList [3]);

			yield return new WaitForSeconds (PrepClass.c_timeGap);
			
        }
	}



	/// <summary>
	/// 깃발 색 변환
	/// </summary>
	void flagColor(TYPE_TEAM capteam = TYPE_TEAM.NONE){
		for(int i = 0; i < m_flagList.Length; i++){
			//거점에 점수가 있을 경우
			if(m_flagList[i] > 0){
				//점수에 맞게 색 변환
				GetComponent<SpriteRenderer>().color = PrepClass.getFlagColor(team, capteam, PrepClass.ratioCalculator(m_flagList[i], c_captureMax));
				//막대바 사이즈 변환
				//m_point = m_flagList[i];
				//m_flagDel(team, capteam, PrepClass.ratioCalculator(m_flagList[i], c_captureMax));
				break;
			}
		}
	}


	/// <summary>
	/// 깃발 바꾸기
	/// </summary>
	/// <param name="team">Team.</param>
	void flagChange(TYPE_TEAM team){
		m_team = team;
		//점령시 null 오류 있음
		m_captureBroadCast(flagTag, team);
		StartCoroutine (effectCoroutine ());
		//m_flagDel(team, capteam, PrepClass.ratioCalculator(m_flagList[(int)team], c_captureMax));
	}



	//이펙트 코루틴
	IEnumerator effectCoroutine(){
		m_captureEffect.SetActive (true);

		yield return new WaitForSeconds (0.25f);

		m_captureEffect.SetActive (false);
	}

}



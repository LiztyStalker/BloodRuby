//------------------------------------------------------------------------------
// <auto-generated>
//     이 코드는 도구를 사용하여 생성되었습니다.
//     런타임 버전:4.0.30319.36373
//
//     파일 내용을 변경하면 잘못된 동작이 발생할 수 있으며, 코드를 다시 생성하면
//     이러한 변경 내용이 손실됩니다.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

using System.Collections;
using UnityEngine;
public class UICameraCtrlClass : MonoBehaviour
{
	//캐릭터 이동 카메라 추가 가중치
	const float c_cameraVelocity = 3f;
	const float c_cameraMaxSize = 8f;
	const float c_cameraDefaultSize = 6f;

	const float c_cameraForceVelocity = 0.1f;

	float m_cameraSizeDistance = 0f;
	float m_cameraForceHeight = 0f;
	float m_cameraForce = 0f;
	float orthographicSize;

	Vector2 m_characterVelocity = Vector2.zero;

	PlayerClass m_player = null;
	bool m_isTelescope = false;
//	bool m_isBuild = false;

	//카메라 최대값
	Vector2 m_maxRect;

	//망원경 최대값
	Vector2 m_maxTelescopeRect;

	//스킬 최대값
	float m_radius;

	Vector3 m_cameraPos = Vector2.zero;
	Vector2 m_velocity = Vector2.zero;

    Coroutine m_cameraCo = null;

	void Start(){
//		m_player = GameObject.Find ("Game@Player").GetComponent<PlayerClass>();
		StartCoroutine(cameraShakeCoroutine());
	}




	public void setCamera(PlayerClass player, Vector2 rect, Vector2 telescopeRect){
		m_player = player;
		m_maxRect = rect;
		m_maxTelescopeRect = telescopeRect;

		m_isTelescope = false;
		m_velocity = Vector2.zero;

		orthographicSize = c_cameraDefaultSize;
		//Debug.Log ("cameraSet");

		//카메라 동기화 초기화 A0.8
		initCharacterPosition ();
	}

	public void setSkillGuideRange(float radius){
		m_radius = radius;
	}

	void Update(){

//		Debug.Log ("Camera : " + Camera.main.transform.position);

		if (m_player == null)
			return;

		if (!m_isTelescope || m_cameraCo != null)
			characterMove ();
	}


	//A0.8 FixedUpdate → LateUpdate
	void LateUpdate(){
		//망원경 상태일때 이동중이 아니면
		if (m_isTelescope && !m_player.isMove){
			if (Input.touchCount > 1) {
				//A0.8 리팩토링 완료
				float distance = Vector2.Distance (Input.GetTouch (0).position, Input.GetTouch (1).position);

				//줌인, 줌아웃
				if (distance > m_cameraSizeDistance || distance < m_cameraSizeDistance) {
					cameraZoom (distance - m_cameraSizeDistance);
					m_cameraSizeDistance = distance;
				} 

				//A0.7
				//손가락 범위가 넓어지면 확대
//				if (Vector2.Distance (Input.GetTouch (0).position, Input.GetTouch (1).position) > m_cameraSizeDistance) {
//					//Out
//					cameraZoom(Vector2.Distance (Input.GetTouch (0).position, Input.GetTouch (1).position) - m_cameraSizeDistance);
//				}
//				//손가락 범위가 좁아지면 축소
//				else if (Vector2.Distance (Input.GetTouch (0).position, Input.GetTouch (1).position) < m_cameraSizeDistance) {
//					//In
//					cameraZoom(Vector2.Distance (Input.GetTouch (0).position, Input.GetTouch (1).position) - m_cameraSizeDistance);
//				}
//				m_cameraSizeDistance = Vector2.Distance (Input.GetTouch (0).position, Input.GetTouch (1).position);
			}

			//A0.8 카라 
			Camera.main.orthographicSize = orthographicSize;//Mathf.Lerp(Camera.main.orthographicSize, orthographicSize, 0.1f);
		}
		else {
			cameraZoom (c_cameraDefaultSize);
		}
	}


	public void telescopeMove(float dirX, float dirY){

		//최대값 없음
		if (m_radius == 0f) {




//			Debug.Log ("telscopeMove");

			m_velocity.Set (dirX, dirY);
			GetComponent<Rigidbody2D> ().velocity = m_velocity * PrepClass.c_cameraSpeedOffset * Time.deltaTime * PrepClass.c_moveSpeedOffset;


			//맵 최대치에 도달했을 경우 카메라가 움직이지 않음
			float clampX = Mathf.Clamp (transform.position.x, -m_maxTelescopeRect.x, m_maxTelescopeRect.x);
			float clampY = Mathf.Clamp (transform.position.y, -m_maxTelescopeRect.y, m_maxTelescopeRect.y);

			m_cameraPos.Set(clampX, clampY, -10f);

			transform.position = m_cameraPos;




		} else {

//			//최대 사정거리 이상 못 움직임
//			if (maxDistance <= Vector2.Distance (transform.position, m_player.transform.position)) {
//				
//			}

			m_velocity.Set (dirX, dirY);
			GetComponent<Rigidbody2D> ().velocity = m_velocity * PrepClass.c_cameraSpeedOffset * Time.deltaTime * PrepClass.c_moveSpeedOffset;


			Vector2 axis = ((Vector2)transform.position - (Vector2)m_player.transform.position).normalized;

			//거리
			float distance = Vector2.Distance (transform.position, m_player.transform.position);

			//반지름보다 크면
			if (distance > m_radius)
				//최대값
				transform.position = m_player.transform.position + (Vector3)axis * m_radius + (Vector3.back * 10f);
			else
				//거리
				transform.position = m_player.transform.position + (Vector3)axis * distance + (Vector3.back * 10f);
			
		}
	}

	public void setTelescope(bool isTelescope){
		m_isTelescope = isTelescope;

		//카메라 시동시 가속도 초기화
		GetComponent<Rigidbody2D> ().velocity = Vector2.zero;

		//카메라 종료시
		if (!m_isTelescope) {
			m_radius = 0f;
			characterMove ();
			//m_cameraCo = StartCoroutine (telescopeRelease ());
		}

	}

	//카메라 종료시 부드럽게 캐릭터로 이동
	//사용 안함
	IEnumerator telescopeRelease(){
		while (0.1f < Vector2.Distance(transform.position, m_player.transform.position)) {
			transform.position = (Vector3)Vector2.Lerp(transform.position, m_player.transform.position, 1f) + (Vector3.back * 10f);
			yield return new WaitForSeconds(PrepClass.c_timeGap);
		}

        m_cameraCo = null;
	}

	/// <summary>
	/// 카메라 이동 가중치 부여 A0.8
	/// </summary>
	/// <param name="vX">V x.</param>
	/// <param name="vY">V y.</param>
	public void setCharacterVelocity(float vX, float vY){
		m_characterVelocity.Set (vX, vY);
	}

	/// <summary>
	/// 캐릭터 이동
	/// 해당 방향으로 추가 이동 A0.8
	/// 사용 안함
	/// </summary>
	/// <param name="vX">V x.</param>
	/// <param name="vY">V y.</param>
	public void characterMove(){

		//어지럼증이 있어 해당 위치에 보간법 필요

		//이동 가중치 추가
		float vX = m_characterVelocity.x * c_cameraVelocity;
		float vY = m_characterVelocity.y * c_cameraVelocity;

		//맵 최대치에 도달했을 경우 카메라가 움직이지 않음
		float clampX = Mathf.Clamp (m_player.transform.position.x + vX , -m_maxRect.x, m_maxRect.x);
		float clampY = Mathf.Clamp (m_player.transform.position.y + vY, -m_maxRect.y, m_maxRect.y);
	
		m_cameraPos.Set(clampX, clampY, -10f);


		transform.position = Vector3.Lerp (m_cameraPos, transform.position, 0.5f);
	}

	/// <summary>
	/// 캐릭터와 카메라 동기화 초기화 A0.8
	/// </summary>
	void initCharacterPosition(){
		float clampX = Mathf.Clamp (m_player.transform.position.x , -m_maxRect.x, m_maxRect.x);
		float clampY = Mathf.Clamp (m_player.transform.position.y, -m_maxRect.y, m_maxRect.y);
		m_cameraPos.Set(clampX, clampY, -10f);
		transform.position = m_cameraPos;

	}

	/// <summary>
	/// 캐릭터 이동 A0.8
	/// </summary>
	/// <param name="angle">Angle.</param>
	public void characterMove(float angle){
		float vX = Mathf.Cos (angle * Mathf.Deg2Rad) * c_cameraVelocity;
		float vY = Mathf.Sin (angle * Mathf.Deg2Rad) * c_cameraVelocity;
		setCharacterVelocity (vX, vY);
//		characterMove (vX, vY);
	}


	/// <summary>
	/// 캐릭터 이동 A0.8
	/// </summary>
	/// <param name="dirX">Dir x.</param>
	/// <param name="dirY">Dir y.</param>
	public void characterMove(float dirX, float dirY){
		setCharacterVelocity (dirX, dirY);
		//		characterMove (vX, vY);
	}


	/// <summary>
	/// 카메라 줌 인, 줌 아웃 A0.8
	/// 5~8
	/// </summary>
	public void cameraZoom(float cameraSize){

		if (!m_isTelescope) {
			Camera.main.orthographicSize = c_cameraDefaultSize;
			orthographicSize = c_cameraDefaultSize;
		}
		else {
			cameraSize *= 0.01f;
			//줌 인시 -값

			if (orthographicSize - cameraSize > c_cameraMaxSize)
				return;
			//줌 아웃시 + 값
			else if (orthographicSize - cameraSize < c_cameraDefaultSize)
				return;
//			
			Debug.Log ("CameraZoom : " + cameraSize);
//
//
			orthographicSize -= cameraSize;
//			Camera.main.orthographic = false;
			//Debug.Log ("CameraZoom : " + Camera.main.orthographicSize);
		}

	}

	/// <summary>
	/// 카메라 흔들기 A0.8
	/// 사용하지 않음

	/// </summary>
	public void cameraShake(float force = 0f){
		m_cameraForce = force;
		m_cameraForceHeight = force;
	}


	/// <summary>
	/// 카메라 흔들기 코루틴 A0.8
	/// 사용하지 않음
	/// </summary>
	/// <returns>The shake coroutine.</returns>
	IEnumerator cameraShakeCoroutine(){
		while (gameObject.activeSelf) {

			if (Mathf.Abs(m_cameraForceHeight) > 0.01f) {

				m_cameraForce -= m_cameraForceHeight;
				m_cameraForceHeight *= -0.5f;


				Camera.main.orthographicSize += m_cameraForce;

			} else {
				m_cameraForceHeight = 0f;
				m_cameraForce = 0f;
				Camera.main.orthographicSize = c_cameraDefaultSize;
			}

			yield return new WaitForSeconds (PrepClass.c_timeGap * 0.1f);
		}
	}


}



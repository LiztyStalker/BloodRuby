//------------------------------------------------------------------------------
// <auto-generated>
//     이 코드는 도구를 사용하여 생성되었습니다.
//     런타임 버전:4.0.30319.36373
//
//     파일 내용을 변경하면 잘못된 동작이 발생할 수 있으며, 코드를 다시 생성하면
//     이러한 변경 내용이 손실됩니다.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using UnityEngine;
using System.Linq;

public class UICPUClass : UICharacterClass
{

	//레벨 난이도
	//1 쉬움 2 정예
	//3 보통 4 정예
	//5 어려움 6 정예
	//7 전문가 8 정예
	//9 극한 10 정예
//	[SerializeField] int m_level;

	AINodeClass m_aiCtrler;

	[SerializeField] Sprite m_cpuIcon;
	[SerializeField] CPUClass m_enemy;
	[SerializeField] bool m_isDummy;


	[SerializeField] TYPE_TEAM m_selectTeam; //팀선택
	[SerializeField] TYPE_MOS m_dummyMos; //병과
	[SerializeField] int m_nowHealth; //체력
	[SerializeField] int[] equipmentArray; //장비배열

	[SerializeField] bool m_isInvisible; //무적여부
	[SerializeField] bool m_isAttack; //공격여부
	[SerializeField] bool m_isMove; //이동여부
	[SerializeField] bool m_isSkill; //스킬여부

	[Range(0, 3)]
	[SerializeField] int m_skillRun; //스킬사용


//    TYPE_MOS[] m_tmpmos = {TYPE_MOS.ASSAULT, TYPE_MOS.FIREBAT, TYPE_MOS.HEAVY, TYPE_MOS.SNIPER};

	CaptureObjectClass[] m_flags;
	CPUClass m_cpu = null;
    Transform m_point = null;

	public override ICharacterInterface character {	get {return (m_cpu == null) ? null: m_cpu;}}
	//A0.8
	public Transform point{ get { return m_point = m_ctrler.mapData.getPoint (m_point); } }

	void Start(){gameStart ();}

	public override void gameStart (){
//		team = TYPE_TEAM.TEAM_1;
		m_icon = m_cpuIcon;
		m_respawnTime = -m_respawnTimeMax;
		m_level = m_ctrler.level;
	}

	public override void gameUpdate (GameControllerClass ctrler)
	{
		//throw new NotImplementedException ();
		//적 캐릭터 제어

        m_ctrler = ctrler;

		//사망

		//if (!m_isCtrl)	return;




		//시작
		if (m_respawnTime < 0f)
        {

//			Debug.Log ("사망 : " + m_respawnTime);

			m_respawnTime += PrepClass.c_timeGap;
			if(m_respawnTime > 0f){

				if(m_cpu != null) Destroy (m_cpu.gameObject);
				
				cpuGameSetting (ctrler);
				m_respawnTime = 0f;
			}
		}
		//게임중
		else {
            //게임 진행

			if (m_cpu != null) {

				//모든 AI는 여기서 조종
				//0.1초 틱
				m_cpu.isGameRun = ctrler.isGameRun;
				if(m_cpu.isGameRun)
					m_aiCtrler.Run (m_cpu);



				//게임 진행중


				return;


				//이동 방향으로 몸 회전 - 공격방향으로 몸 회전

				//이동중 적 발견
				//알고리즘 실행
				//공격, 지원, 방어
				//공격
				//	공격 - 먼 지역으로 이동. 적 발견시 추적. 거점 점령중이어도 적 발견시 추적
				//	지원 - 랜덤 이동. 적 발견시 추적 안함. 거점 점령 우선
				//	방어 - 가까운 지역 이동. 적 발견시 추적 안함. 점령당할시 이동


				//A0.8 사용하지 않음 - BT 알고리즘으로 이동
//				if (m_cpu.setTarget ()) {
//
//					//
//					//m_cpu.algorism ();
//					//전략패턴 알고리즘 실행
//					//스킬 및 각종 행동 실행
//				}


				//첫 포인트 등록
//				if (m_pointer == null) {
//					m_pointer = ctrler.mapData.getPoint (null);
//				}

				//현재 목표에 도달하면
				//A0.8 현재 경로와 같은 값이 나오지 않음 - 사용하지 않음
//				if (m_cpu.setDestination ()) {
////					Debug.Log ("next Pos");
//
////					while(true) {
//						//목표 가져오기
////						Transform nextPointer = ctrler.mapData.getPoint (m_pointer);
//						//같은 목표가 아니면
////						if (nextPointer != m_pointer) {
////							//다음 포인트 예약
//					m_point = ctrler.mapData.getPoint (m_point);
//					Debug.Log ("point : " + m_point.position);	
////							break;
////						}
////					}
//				} 




			}


            //거점이 중립 또는 적 거점이면 대기
            //enemy.moveAction();

            //아군 거점이 되거나 아군거점이면 위로 반복
            //restart


		}

		//cpuGameSetting(ctrler);
		
		//플레이어가 처음 생성되었거나 타이머가 완료되었을 경우
		//캐릭터 생성
		
		
		//컴퓨터 작동
		//게임에서 지고있거나 이기고 있을 경우 
		//게임 컨트롤러가 계속 입력

	}

	public override void gameRestart ()
	{
		//컴퓨터 작동	
		//gameReady 실행
	}

	public override void gameReady (TYPE_MOS mos, int[] equipments, CaptureObjectClass flag)
	{


//		Vector3 vec = new Vector3(Random.Range (0f, 1f), Random.Range(0f, 1f), 0f);
//		vec = Camera.main.ViewportToWorldPoint(vec);
//		vec.z = 0f;


        m_cpu = (CPUClass)Instantiate(m_enemy, flag.respawnPos, new Quaternion());
        Debug.Log("enemyPos : " + m_cpu.transform.position);


		//컴퓨터 작동
		//컴퓨터는 해당 캐릭터 중 랜덤으로 하나를 고름 
		//같은 팀 거점 중 랜덤으로 하나를 또 골라서 배치


		//거점 배치

		//m_pointer = flag.transform;
        m_cpu.gameReady(this, mos, equipments);
		m_cpu.buffAdd (respawnInvisibleBuff, m_cpu, m_cpu);

		//AI 등록
		if (m_aiCtrler == null) m_aiCtrler = AIManagerClass.GetInstance.getBT ();
		//m_aiCtrler.setCPU (m_cpu);
		

	}

	/// <summary>
	/// 컴퓨터 리스폰
	/// </summary>
	public override void gameRespawn(UICharacterClass inflictCharacter, IBullet bullet)
    {

		//컴퓨터 작동
		//컴퓨터 사망 - 리스폰 종료시 gameRestart로 이동
		base.gameRespawn(inflictCharacter, bullet);

	}

	void cpuGameSetting(GameControllerClass ctrler){

		m_flags = ctrler.mapData.flags.Where (flag => flag.team == team).ToArray<CaptureObjectClass> ();

		if (m_flags.Length > 0) {

			TYPE_MOS mos = (TYPE_MOS)UnityEngine.Random.Range(0, Enum.GetValues(typeof(TYPE_MOS)).Length);
			//TYPE_MOS mos = TYPE_MOS.MAGICIAN;
                //(TYPE_MOS)UnityEngine.Random.Range(0, Enum.GetValues(typeof(TYPE_MOS)).Length);
			int[] equips = new int[3];

			int index = UnityEngine.Random.Range (0, m_flags.Length);
			CaptureObjectClass flag = m_flags [index];

			gameReady (mos, equips, flag);
			m_respawnTime = 0f;

			if (ctrler.mode == TYPE_MODE.TRAINING) m_cpu.isDummy = true;

		} else {
			m_respawnTime = 4f;
		}
		//깃발이 없으면 소환 불가
	}

	/// <summary>
	/// 게임 종료
	/// </summary>
	/// <param name="endType">End type.</param>
	public override void gameEnd (TYPE_GAMEEND endType)
	{
		base.gameEnd (endType);
        if (m_cpu != null) m_cpu.gameEnd();	
	}

    /// <summary>
    /// 메시지 출력
    /// </summary>
    /// <param name="msg"></param>
    /// <param name="flag"></param>
    public override void setMsg(string flagTag, CaptureObjectClass flag) {
		//적팀이 거점 점령중이면
		//
		//가까운 캐릭터 10이 0%, 0이 100% 확률로 이동


	}
	public override void closeMsg (){}


	//
	public override void gameHistory (GameControllerClass ctrler){}

}



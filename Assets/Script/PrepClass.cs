//------------------------------------------------------------------------------
// <auto-generated>
//     이 코드는 도구를 사용하여 생성되었습니다.
//     런타임 버전:4.0.30319.36373
//
//     파일 내용을 변경하면 잘못된 동작이 발생할 수 있으며, 코드를 다시 생성하면
//     이러한 변경 내용이 손실됩니다.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;

public enum TYPE_LANG{kor, eng}


public static class PrepClass
{


//	public enum TYPE_CTRLER{NONE = -10, RELOAD = -1, SKILL0, SKILL1, SKILL2, SKILL3, TELESCOPE}



	public static System.Globalization.TextInfo TypeTextInfo = System.Globalization.CultureInfo.CurrentCulture.TextInfo;
		

	public static TYPE_LANG typeLanguage;

	public static readonly string newsPath = "Data/Patch/Patch_";

	public static readonly string textDataPath = "Data/TextInfo/TextInfo_";
	public static readonly string tipDataPath = "Data/Tip/Tip_";
	public static readonly string tipImagePath = "Image/Tip/Tip_";
	public static readonly string contentsPath = "Data/Contents/contents_";

	public static readonly string fontPath = "Font";
	public static readonly string fontName = "NANUMBARUNGOTHIC";

	public static bool isBGM = false;
	public static bool isEffect = false;

    public readonly static int[] m_times = { 10, 15, 20 };
    public readonly static int[] m_populations = {4, 6, 8 };
    public readonly static int[] m_tickets = {250, 500, 750 };
    public readonly static bool[] m_captures = { true, false };
    public readonly static bool[] m_items = { true, false };
    public readonly static int[] m_levels = { 1, 3, 5 };
    public readonly static int[] m_respawns = { 3, 4, 5 };

	public static string getLanguagePath(string path){
		return path + typeLanguage.ToString();
	}

	public readonly static string[] m_cpuName = {
		"알파",
		"찰리",
		"브라보",
		"델타",
		"이지",
		"폭스",
		"그리즐리",
		"엘리펀트",
		"수잔",
		"블랙베어",
		"헌터",
		"스코프",
		"불독",
		"페르시아",
		"시스터",
		"감마"
	};
		
	/// <summary>
	/// 각 팀간 색상
	/// 팀0 - 파랑
	/// 팀1 - 노랑 -> 빨강
	/// 팀2 - 녹색
	/// 팀3 - 마젠타
	/// 중립 - 회색
	/// 적 - 빨강 -> 노랑
	/// </summary>
	readonly static Color[] c_flagColor = {
		/// 

		Color.blue, 
		Color.red, 
		Color.green, 
		Color.magenta, 
		Color.gray, 
		Color.yellow
	};

	/// 
    public static int length(int index)
    {
        switch ((TYPE_MAP_PANEL)index)
        {
            case TYPE_MAP_PANEL.MODE:
                return Enum.GetValues(typeof(TYPE_MODE)).Length;
            case TYPE_MAP_PANEL.POPULATION:
                return m_populations.Length;
            case TYPE_MAP_PANEL.RESPAWN:
                return m_respawns.Length;
            case TYPE_MAP_PANEL.TICKET:
                return m_tickets.Length;
            case TYPE_MAP_PANEL.TIME:
                return m_times.Length;
            case TYPE_MAP_PANEL.CAPTURE:
                return m_captures.Length;
            case TYPE_MAP_PANEL.ITEM:
                return m_items.Length;
            case TYPE_MAP_PANEL.LEVEL:
                return m_levels.Length;
            default:
                return 0;
        }
    }



	/// <summary>
	/// 캐릭터 태그 체크하기
	/// </summary>
	/// <returns><c>true</c>, if character tag was checked, <c>false</c> otherwise.</returns>
	/// <param name="tag">Tag.</param>
	public static bool isCharacterTag(string tag){
		return (tag == "Character");
	}


	/// <summary>
	/// 각종 스킬 및 버프 설명 보기 전 타이머
	/// </summary>
	public const float c_contentViewTime = 1f;


	/// <summary>
	/// 스킬 개수
	/// </summary>
	public const int c_skillCnt = 4;

	/// <summary>
	/// 집탄율 거리 기준
	/// </summary>
	const float c_accuracyLength = 10f;

	/// <summary>
	/// 집탄율 범위 최대
	/// </summary>
	const float c_accuracyHeight = 6f;


	/// <summary>
	/// 프레임 타임 - 10fps
	/// </summary>
	public const float c_timeGap = 0.1f;

	/// <summary>
	/// 캐릭터 이동 속도 오프셋
	/// </summary>
	public const float c_moveSpeedOffset = 100f;

	/// <summary>
	/// 카메라 이동 속도 오프셋
	/// </summary>
	public const float c_cameraSpeedOffset = 5f;




	/// <summary>
	/// 로딩 씬 인덱스
	/// </summary>
	public const string c_LoadPanelScene = "Game@Load";


    /// <summary>
    /// 메인 씬 인덱스
    /// </summary>
	public const string c_MainPanelScene = "Game@Main";


	/// <summary>
	/// 로비 씬 인덱스
	/// </summary>
	public const string c_LobbyPanelScene = "Game@Lobby";


	/// <summary>
	/// 게임 씬 인덱스
	/// </summary>
	public const string c_GamePanelScene = "Game@Play";





	/// <summary>
	/// 집탄율 각도 출력
	/// </summary>
	/// <returns>The calculator.</returns>
	/// <param name="accuracy">집탄율.</param>
	/// <param name="recoil">반동.</param>

	public static float accuracyCalculator(float accuracy, float recoil = 0f){


		/// 
		/// 
		accuracy = (100f - accuracy) * 0.1f;
		///  0~3 

		if (accuracy > c_accuracyHeight) accuracy = c_accuracyHeight;
		else if (accuracy < 0f) accuracy = 0f;

		return Mathf.Atan2 (accuracy * recoil, c_accuracyLength) * Mathf.Rad2Deg;
	}

	/// <summary>
	/// 팀 색 가져오기
	/// </summary>
	/// <returns>The flag color.</returns>
	/// <param name="team">Team.</param>
	public static Color getFlagColor(TYPE_TEAM nowteam, TYPE_TEAM capteam, float rate){

		int nowIndex = getFlagTeam(nowteam); //거점팀
		int capIndex = getFlagTeam(capteam); //점령중인 팀





		//현재 팀이 중립이면 - 빈 거점
		//점령 팀이 중립이 아니면 - 변함 있음

		//현재 팀이 아군이거나 적군이면 - 사용거점
		//점령 팀이 적군이거나 아군이면 - 변함 있음
		//점령 팀이 중립이면 - 변함 없음 - 거점을 먹지 않았을 경우

		//점령팀은 적이 될 수 없다. - 적은 야만인 취급으로 점령 자체가 불가



		//빈 거점이면
		if (nowteam == TYPE_TEAM.NONE) {

			//점령팀이 아군이나 적군이면
			//중립, 아군적군, 비율 반환
			//거점을 먹지 않아도 스코어가 남은 점령팀이 거점 점령팀으로 설정
			//0에서 1로 넘어가므로 점령 팀이 2번째
			return Color.Lerp (c_flagColor [nowIndex], c_flagColor [capIndex], rate);
			
		} 
		else {
			//점령팀이 아군이나 적군이면
			//중립으로 변환
			//1에서 0으로 넘어가므로 중립이 1번째
			return Color.Lerp (c_flagColor [getFlagTeam(TYPE_TEAM.NONE)], c_flagColor [nowIndex], rate);
		}
	}

	/// <summary>
	/// 팀 색 가져오기
	/// </summary>
	/// <returns>The flag color.</returns>
	/// <param name="team">Team.</param>
	/// <param name="brightness">brightness 0f dark ~ 1f white.</param>
	public static Color getFlagColor(TYPE_TEAM team, float brightness = 0f){


		Color color = c_flagColor [getFlagTeam (team)];

		switch (team) {
		case TYPE_TEAM.TEAM_0:
			color.r = brightness;
			color.g = brightness;
			break;
		case TYPE_TEAM.TEAM_1:
			color.b = brightness;
			color.g = brightness;
			break;
		case TYPE_TEAM.TEAM_2:
			color.b = brightness;
			color.r = brightness;
			break;
		case TYPE_TEAM.TEAM_3:
			color.g = brightness;
			break;
		case TYPE_TEAM.NONE:
			color.g *= brightness;
			color.b *= brightness;
			break;
		}



		return color;
	}

	/// <summary>
	/// 점령팀 인덱스 가져오기
	/// </summary>
	/// <returns>The flag team.</returns>
	/// <param name="team">Team.</param>
	public static int getFlagTeam(TYPE_TEAM team){
		switch (team) {
		case TYPE_TEAM.ENEMY:
			return c_flagColor.Length - 1;
		case TYPE_TEAM.NONE:
			return c_flagColor.Length - 2;
		default:
			return (int)team;
		}
	}

//	public const float c_moveSpeedMax = 10f;
//	public const float c_attactSpeedMax = 0.01f;


	/// <summary>
	/// 비율 계산 0~1
	/// </summary>
	/// <returns>The calculator.</returns>
	/// <param name="min">Minimum.</param>
	/// <param name="max">Max.</param>
	public static float ratioCalculator(float min, float max){
		if (min >= max) return 1f;
		else if (min < 0f) return 0f;
		return min / max;
	}

	/// <summary>
	/// 비율 계산 0~1
	/// </summary>
	/// <returns>The calculator.</returns>
	/// <param name="min">Minimum.</param>
	/// <param name="max">Max.</param>
	public static float ratioCalculator(int min, int max){
		return ratioCalculator ((float)min, (float)max);
	}


	/// <summary>
	/// 각도 정규화 계산 -180~180
	/// </summary>
	/// <returns>The calculator.</returns>
	/// <param name="angle">Angle.</param>
	public static float angleCalculator(float angle){
		if (angle > 180f) angle -= 360f;
		if (angle < -180f) angle += 360f;
		return angle;
	}

	/// <summary>
	/// 반대각 계산
	/// </summary>
	/// <returns>The angle calculator.</returns>
	/// <param name="angle">Angle.</param>
	public static float reverseAngleCalculator(float angle){
		if (angle >= 0f)
			return angleCalculator(angle - 180f);
		return angleCalculator(angle + 180f);
	}

	/// <summary>
	/// 각도 계산
	/// </summary>
	/// <returns>The calculator.</returns>
	/// <param name="dirX">Dir x.</param>
	/// <param name="dirY">Dir y.</param>
	/// <param name="angleOffset">Angle offset.</param>
	public static float angleCalculator(float dirX, float dirY, float angleOffset = 0f){
		return Mathf.Atan2 (dirY, dirX) * Mathf.Rad2Deg + angleOffset;
	}
	/// 
	/// <summary>
	/// 각도 계산기
	/// </summary>
	/// <returns>The calculator.</returns>
	/// <param name="center">중심</param>
	/// <param name="target">목표.</param>
	public static float angleCalculator(Vector2 center, Vector2 target){
		Vector2 direction = target - center;
		return angleCalculator (direction.x, direction.y);
	}

	/// <summary>
	/// 각도간 이동거리
	/// </summary>
	/// <returns>The calculator.</returns>
	/// <param name="movement">Movement.</param>
	/// <param name="angle">Angle.</param>
	public static Vector2 movementCalculator(float movement, float angle){
		float dirX = Mathf.Cos (angleCalculator (angle) * Mathf.Deg2Rad) * movement;
		float dirY = Mathf.Sin (angleCalculator (angle) * Mathf.Deg2Rad) * movement;
		return new Vector2 (dirX, dirY);
	}


	public static ICharacterInterface getCharacter(ICharacterInterface ownerCharacter, ICharacterInterface otherCharacter, bool isAlly, bool isDead, bool isMyself){

		//자신, 동맹, 적군

		//동맹이면 자신 포함여부
		//적군이면
		return getAlly (ownerCharacter, otherCharacter, isAlly, isDead, isMyself);

	}


	static ICharacterInterface getAlly(ICharacterInterface ownerCharacter, ICharacterInterface otherCharacter, bool isAlly, bool isDead, bool isMyself){
		//아군이면

		TYPE_TEAM team = TYPE_TEAM.ENEMY;

		//공격자가 null이 아닌지 여부
		if (ownerCharacter != null)
			team = ownerCharacter.team;


		//아군이면
		if (isAlly && team == otherCharacter.team) {
			//자신 포함 여부

			ICharacterInterface myself = getMyself(ownerCharacter, otherCharacter);
			//자신을 포함하면 자신 반납 - 
			if (isMyself && myself != null)
				return myself;
			
			//아니면 - 자신을 제외 아군만
			else if(myself == null)
				return deadCheck (otherCharacter, isDead);
		}
		//적군이면
		else if (!isAlly && team != otherCharacter.team) 
			return deadCheck (otherCharacter, isDead);
		
		return null;
	}


	static ICharacterInterface getMyself(ICharacterInterface ownerCharacter, ICharacterInterface otherCharacter){
		if(ownerCharacter.playerName == otherCharacter.playerName) return ownerCharacter;
		return null;
	}


	static ICharacterInterface deadCheck(ICharacterInterface character, bool isDead){
		//자신이면
		if(isDead && character.isDead)
			return character;
		else if(!isDead && !character.isDead)
			return character;
		return null;
	}
}


